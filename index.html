<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Flash Cards ‚Ä¢ H·ªçc nhanh</title>
<style>
  :root { --bg1:#0f172a; --bg2:#1e293b; --fg:#f1f5f9; --muted:#cbd5e1;
          --panel:rgba(255,255,255,.06); --panel2:rgba(255,255,255,.1); --border:rgba(255,255,255,.18);
          --accent:rgba(56,189,248,.25); }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Helvetica,Arial,sans-serif;
       background:linear-gradient(135deg,var(--bg2),var(--bg1));color:var(--fg)}
  header,footer{padding:10px 20px}
  header h1{margin:0;font-size:1.4rem}
  #stats{opacity:.9;margin-top:4px;font-size:.9rem}
  main{display:flex;gap:20px;padding:20px;align-items:flex-start;flex-wrap:wrap}
  .col{flex:1 1 360px;min-width:320px}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,textarea,select{width:100%;padding:10px;border-radius:8px;border:1px solid var(--border);background:rgba(15,23,42,.5);color:var(--fg);outline:none}
  input:focus,textarea:focus,select:focus{box-shadow:0 0 0 2px var(--accent)}
  .btn{padding:8px 12px;border-radius:8px;border:1px solid var(--border);background:var(--panel);color:var(--fg);cursor:pointer}
  .btn:hover{background:var(--panel2)}
  #card{min-height:260px;position:relative;cursor:pointer;display:flex;align-items:center;justify-content:center;text-align:center}
  #card .badge{position:absolute;left:10px;top:10px;display:flex;gap:6px;align-items:center}
  .ipa{font-size:.8rem;background:rgba(0,0,0,.35);padding:2px 6px;border-radius:6px}
  #loading{font-size:.9rem;color:var(--muted)}
  .list{max-height:460px;overflow:auto}
  .list-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:var(--panel);border:1px solid var(--border);cursor:pointer;margin-bottom:6px}
  .list-item.active{background:var(--accent)}
  small{color:var(--muted)}
  .kpx{display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap}
  /* Badge tr·∫°ng th√°i sync */
  #syncStatus{
    position:fixed; right:12px; bottom:12px; padding:8px 12px; border-radius:10px;
    background:rgba(15,23,42,.75); border:1px solid var(--border); font-size:.85rem;
    color:var(--fg); backdrop-filter: blur(6px);
  }
  #syncStatus.ok { border-color:rgba(16,185,129,.45) }
  #syncStatus.work { border-color:rgba(56,189,248,.45) }
  #syncStatus.err { border-color:rgba(244,63,94,.55) }
</style>
</head>
<body>

<header>
  <h1>Flash Cards ‚Ä¢ H·ªçc nhanh</h1>
  <div id="stats"></div>
</header>

<main>
  <!-- C·ªôt tr√°i: xem & thao t√°c -->
  <section class="col panel" style="display:flex;flex-direction:column;gap:12px;">

    <!-- B·ªô th·∫ª (sets) -->
    <div class="panel">
      <div class="row">
        <select id="setSelect" title="Ch·ªçn b·ªô th·∫ª" style="flex:1 1 220px;"></select>
        <button id="setAddBtn" class="btn" title="T·∫°o b·ªô th·∫ª m·ªõi">+ B·ªô th·∫ª</button>
        <button id="setRenameBtn" class="btn" title="ƒê·ªïi t√™n b·ªô th·∫ª">ƒê·ªïi t√™n</button>
        <button id="setDeleteBtn" class="btn" title="X√≥a b·ªô th·∫ª">X√≥a b·ªô</button>
      </div>
    </div>

    <!-- √î t√¨m ki·∫øm + ƒëi·ªÅu h∆∞·ªõng th·∫ª -->
    <div class="row">
      <input id="search" placeholder="T√¨m th·∫ª..." style="flex:1 1 220px;">
      <button id="prevBtn" class="btn" title="Tr∆∞·ªõc (‚Üê)">‚Üê</button>
      <button id="nextBtn" class="btn" title="Sau (‚Üí)">‚Üí</button>
      <button id="deleteBtn" class="btn" title="X√≥a th·∫ª hi·ªán t·∫°i (Delete)">üóë</button>
    </div>

    <!-- Flashcard -->
    <div id="card" class="panel" style="min-height:280px">
      <div class="badge">
        <span id="cardIpa" class="ipa"></span>
        <button id="speakBtn" class="btn" title="Ph√°t √¢m">üîä</button>
      </div>
      <div style="position:absolute;right:10px;top:10px;"><small>Nh·∫•n ƒë·ªÉ l·∫≠t ‚Ä¢ Space / Enter</small></div>
      <div id="cardContent" style="white-space:pre-line;font-size:1.6rem;line-height:1.4"></div>
    </div>

    <!-- H√†nh ƒë·ªông th·∫ª -->
    <div class="kpx">
      <button id="unknownBtn" class="btn" title="D">Ch∆∞a thu·ªôc</button>
      <button id="flipBtn" class="btn">L·∫≠t th·∫ª</button>
      <button id="knownBtn" class="btn" title="A">ƒê√£ thu·ªôc</button>
      <span id="loading" hidden>ƒêang l·∫•y IPA‚Ä¶</span>
    </div>
  </section>

  <!-- C·ªôt ph·∫£i: th√™m t·ª´ & danh s√°ch -->
  <aside class="col" style="display:flex;flex-direction:column;gap:12px;">
    <div class="panel">
      <h3 style="margin:6px 0 10px">Th√™m t·ª´ m·ªõi</h3>
      <input id="inFront" placeholder="Th√¥ng tin 1 (M·∫∑t tr∆∞·ªõc) ‚Äî t·ª± th√™m IPA & ph√°t √¢m">
      <div id="frontHint"><small></small></div>
      <textarea id="inBack" rows="4" placeholder="Th√¥ng tin 2 (M·∫∑t sau) ‚Äî nghƒ©a/ghi ch√∫"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="addBtn" class="btn" style="flex:1" title="N">Th√™m t·ª´</button>
        <button id="clearBtn" class="btn">Xo√° nh·∫≠p</button>
      </div>
      <div style="margin-top:6px"><small>
        Ph√≠m t·∫Øt: A = ƒê√£ thu·ªôc, D = Ch∆∞a thu·ªôc, Space/Enter = L·∫≠t, N = Nh·∫≠p nhanh, ‚Üê/‚Üí = chuy·ªÉn th·∫ª, Delete = X√≥a th·∫ª
      </small></div>
    </div>

    <div class="panel">
      <h3 style="margin:6px 0 10px">Danh s√°ch th·∫ª</h3>
      <div id="list" class="list"></div>
    </div>
  </aside>
</main>

<footer>
  ¬© Ver 1.2 ‚Äî L∆∞u t·ª± ƒë·ªông trong tr√¨nh duy·ªát ‚Ä¢ C√≥ IPA & ph√°t √¢m ‚Ä¢ ƒê·ªìng b·ªô nhi·ªÅu ng∆∞·ªùi d√πng
</footer>

<!-- Badge tr·∫°ng th√°i ƒë·ªìng b·ªô -->
<div id="syncStatus" class="work">ƒêang kh·ªüi t·∫°o‚Ä¶</div>

<script>
/* =================== State t·ªïng (nhi·ªÅu b·ªô th·∫ª) =================== */
const STORAGE_KEY = 'flashcards_v4_sets';

let state = loadInitialState();
/*
  state = {
    version: 4,
    activeSetId: 'set_xxx',
    sets: [
      { id:'set_1', name:'B·ªô th·∫ª c·ªßa t√¥i', cards:[{id,front,back,ipa,audio,example,known,unknown,last}, ...] },
      ...
    ]
  }
*/
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); setDirty(); }
function loadInitialState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const s = JSON.parse(raw);
      if(s && Array.isArray(s.sets) && s.sets.length){
        if(!s.activeSetId || !s.sets.find(x=>x.id===s.activeSetId)){
          s.activeSetId = s.sets[0].id;
        }
        return { version: 4, ...s };
      }
    }
  }catch(_){}
  // Migration t·ª´ v3
  const oldKey = 'flashcards_v3_plain';
  let migratedCards = [];
  try{
    const rawOld = localStorage.getItem(oldKey);
    if(rawOld){
      const arr = JSON.parse(rawOld);
      if(Array.isArray(arr)) migratedCards = arr;
    }
  }catch(_){}
  const defaultSet = {
    id: uid('set_'),
    name: 'B·ªô th·∫ª c·ªßa t√¥i',
    cards: migratedCards.length ? migratedCards : sampleCards()
  };
  return { version: 4, activeSetId: defaultSet.id, sets:[defaultSet] };
}

/* =================== Helpers chung =================== */
function uid(prefix=''){ return (prefix||'') + Math.random().toString(36).slice(2) + Date.now().toString(36) }
function sampleCards(){
  return [
    { id:uid('c_'), front:"hello", back:"xin ch√†o", known:0, unknown:0, last:0, ipa:"/h…ôÀàl…ô ä/", audio:"", example:"Hello! Nice to meet you." },
    { id:uid('c_'), front:"embedded", back:"nh√∫ng (k·ªπ thu·∫≠t)", known:0, unknown:0, last:0, ipa:"/…™mÀàb…õd…™d/", audio:"", example:"" },
  ];
}
function activeSet(){ return state.sets.find(s => s.id === state.activeSetId) }
function currentCards(){ return activeSet()?.cards || [] }
function setCards(newCards){ const s = activeSet(); if(!s) return; s.cards = newCards; }
function currentCardById(id){ return currentCards().find(c=>c.id===id) }

/* =================== Bi·∫øn UI & sync =================== */
let currentId = currentCards()[0]?.id || null;
let flipped = false;
let dirty = false;          // c√≥ thay ƒë·ªïi local ch∆∞a ƒë·∫©y
let lastSync = 0;
let pushTimer = null;

const el = {
  // Sets
  setSelect: document.getElementById('setSelect'),
  setAddBtn: document.getElementById('setAddBtn'),
  setRenameBtn: document.getElementById('setRenameBtn'),
  setDeleteBtn: document.getElementById('setDeleteBtn'),
  // Cards UI
  search: document.getElementById('search'),
  card: document.getElementById('card'),
  cardContent: document.getElementById('cardContent'),
  cardIpa: document.getElementById('cardIpa'),
  speakBtn: document.getElementById('speakBtn'),
  knownBtn: document.getElementById('knownBtn'),
  unknownBtn: document.getElementById('unknownBtn'),
  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  deleteBtn: document.getElementById('deleteBtn'),
  flipBtn: document.getElementById('flipBtn'),
  inFront: document.getElementById('inFront'),
  inBack: document.getElementById('inBack'),
  frontHint: document.getElementById('frontHint'),
  addBtn: document.getElementById('addBtn'),
  clearBtn: document.getElementById('clearBtn'),
  list: document.getElementById('list'),
  stats: document.getElementById('stats'),
  loading: document.getElementById('loading'),
  sync: document.getElementById('syncStatus'),
};

/* =================== Dictionary (IPA + audio) =================== */
async function fetchDictionary(term){
  const q = String(term || '').trim();
  if(!q) return { ipa:'', audio:'', example:'', pos:[] };
  try{
    const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(q)}`);
    if(!res.ok) throw new Error('no def');
    const data = await res.json();
    const entry = Array.isArray(data) && data[0] ? data[0] : null;

    let ipa='', audio='', example='', pos=[];
    if(entry?.phonetics?.length){
      const p = entry.phonetics.find(x=>x.text) || entry.phonetics[0];
      ipa = p?.text || '';
      const pa = entry.phonetics.find(x=>x.audio) || p;
      audio = pa?.audio || '';
    }
    if(entry?.meanings?.length){
      pos = entry.meanings.map(m=>m.partOfSpeech).filter(Boolean);
      const defWithEx = entry.meanings.flatMap(m => m.definitions || []).find(d => d.example);
      if(defWithEx?.example) example = defWithEx.example;
    }
    return { ipa, audio, example, pos };
  }catch(e){
    return { ipa:'', audio:'', example:'', pos:[] };
  }
}

/* =================== Render Sets & Cards =================== */
function renderSets(){
  el.setSelect.innerHTML = '';
  state.sets.forEach(s=>{
    const opt = document.createElement('option');
    opt.value = s.id; opt.textContent = `${s.name} (${s.cards.length})`;
    if(s.id === state.activeSetId) opt.selected = true;
    el.setSelect.appendChild(opt);
  });
}
function switchSet(id){
  if(!state.sets.find(s=>s.id===id)) return;
  state.activeSetId = id;
  const cs = currentCards();
  currentId = cs[0]?.id || null;
  flipped = false;
  saveState();
  renderSets(); renderCard(); renderList();
  setSync('ƒêang ·ªü: ' + (activeSet()?.name || ''), 'ok');
}
function buildBackHTML(back, example){
  if(example){ return `${escapeHTML(back)}\n\n${wrapSmall('V√≠ d·ª•: ' + example)}`; }
  return escapeHTML(back);
}
function renderCard(){
  const c = currentCards().find(x=>x.id===currentId);
  if(!c){
    el.cardContent.textContent = "Ch∆∞a c√≥ th·∫ª n√†o. H√£y th√™m t·ª´ ·ªü b√™n ph·∫£i.";
    el.cardIpa.textContent = ''; return;
  }
  el.cardIpa.textContent = c.ipa || '';
  el.cardContent[flipped ? 'innerHTML' : 'textContent'] =
    flipped ? buildBackHTML(c.back, c.example) : c.front;
}
function renderList(){
  el.list.innerHTML = '';
  const q = el.search.value.trim().toLowerCase();
  const filtered = currentCards().filter(c => !q || c.front.toLowerCase().includes(q) || c.back.toLowerCase().includes(q));
  filtered.forEach(c=>{
    const div = document.createElement('div');
    div.className = 'list-item' + (c.id===currentId ? ' active' : '');
    div.innerHTML = `<span>${escapeHTML(c.front)} ${c.ipa?`<small>${escapeHTML(c.ipa)}</small>`:''}</span>
                     <span><small>${c.known}‚úì ${c.unknown}√ó</small></span>`;
    div.onclick = ()=>{ currentId = c.id; flipped = false; renderCard(); renderList(); };
    el.list.appendChild(div);
  });
  const total = currentCards().length;
  const k = currentCards().reduce((s,x)=>s+x.known,0);
  const u = currentCards().reduce((s,x)=>s+x.unknown,0);
  el.stats.textContent = `B·ªô: ${(activeSet()?.name)||''} ‚Ä¢ T·ªïng: ${total} ‚Ä¢ ƒê√£ thu·ªôc: ${k} ‚Ä¢ Ch∆∞a thu·ªôc: ${u}`;
}

/* =================== Card Actions =================== */
function indexOfCurrent(){
  return currentCards().findIndex(c => c.id === currentId);
}
function prevCard(){
  const cards = currentCards();
  if(!cards.length) return;
  const idx = indexOfCurrent();
  const prev = (idx > 0 ? idx - 1 : cards.length - 1);
  currentId = cards[prev].id; flipped = false; renderCard(); renderList();
}
function nextCard(){
  const cards = currentCards();
  if(!cards.length) return;
  const idx = indexOfCurrent();
  const next = (idx >= 0 ? (idx + 1) % cards.length : 0);
  currentId = cards[next].id; flipped = false; renderCard(); renderList();
}
function deleteCurrent(){
  const cards = currentCards();
  const idx = indexOfCurrent();
  if(idx < 0) return;
  const removed = cards.splice(idx, 1)[0];
  saveState();
  if(cards.length){
    const next = idx < cards.length ? idx : cards.length - 1;
    currentId = cards[next].id;
  } else {
    currentId = null;
  }
  flipped = false;
  renderCard(); renderList();
  console.debug('Deleted card:', removed?.front);
}
function mark(isKnown){
  const c = currentCards().find(x=>x.id===currentId); if(!c) return;
  if(isKnown) c.known++; else c.unknown++; c.last = Date.now();
  saveState(); nextCard();
}
async function enrichCardById(id, front){
  el.loading.hidden = false;
  const d = await fetchDictionary(front);
  const c = currentCards().find(x=>x.id===id);
  if(c){
    c.ipa = d.ipa || c.ipa;
    c.audio = d.audio || c.audio;
    c.example = d.example || c.example || '';
    saveState();
    if(currentId === id) renderCard();
    renderList();
  }
  el.loading.hidden = true;
}

/* =================== Utils =================== */
function escapeHTML(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function wrapSmall(s){ return `<small>${escapeHTML(s)}</small>` }
function hhmmss(d=new Date()){ return d.toTimeString().slice(0,8) }

/* =================== Cloud Sync (JSONP, chung cho m·ªçi ng∆∞·ªùi) =================== */
/* GI·ªÆ NGUY√äN nh∆∞ b·∫°n y√™u c·∫ßu */
const API_URL   = 'https://script.google.com/macros/s/AKfycbwxNxcSug7Hn3HRKXWgdvi-SFc8Xbj53nS2u6YjimRfx2P2xhmjBLko2V7b0G7b-wCbMA/exec';
const API_TOKEN = 'abcdefgh';

/* JSONP helper */
function jsonp(url, timeoutMs = 12000) {
  return new Promise((resolve, reject) => {
    const cbName = '__jsonp_cb_' + Math.random().toString(36).slice(2);
    const finalUrl = url + (url.includes('?') ? '&' : '?') + 'callback=' + cbName;
    const script = document.createElement('script');
    let done = false;
    const timer = setTimeout(() => { if (done) return; done = true; cleanup(); reject(new Error('JSONP timeout')); }, timeoutMs);
    function cleanup(){ clearTimeout(timer); delete window[cbName]; script.remove(); }
    window[cbName] = (data)=>{ if(done) return; done = true; cleanup(); resolve(data); };
    script.onerror = ()=>{ if(done) return; done = true; cleanup(); reject(new Error('JSONP load error')); };
    script.src = finalUrl;
    document.head.appendChild(script);
  });
}
function b64webSafeFromJSON(obj){
  const json = JSON.stringify(obj);
  const b64 = btoa(unescape(encodeURIComponent(json)));
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

/* ===== Compact h√≥a ===== */
function compactCards(cards){
  return (cards||[]).map(c => [
    c.id || '',
    c.front || '',
    c.back || '',
    c.ipa || '',
    Number(c.known)||0,
    Number(c.unknown)||0,
    Number(c.last)||0
  ]);
}
function expandCards(arr){
  if (!Array.isArray(arr)) return [];
  if (arr.length && Array.isArray(arr[0])) {
    return arr.map(a => ({
      id:a[0], front:a[1], back:a[2], ipa:a[3],
      known:Number(a[4])||0, unknown:Number(a[5])||0, last:Number(a[6])||0,
      audio:'', example:''
    }));
  }
  return arr;
}
function compactState(st){
  return {
    version: 4,
    activeSetId: st.activeSetId,
    sets: (st.sets||[]).map(s => ({ id:s.id, name:s.name, count:(s.cards||[]).length }))
  };
}
function buildStateFull(st){
  return {
    version: 4,
    activeSetId: st.activeSetId,
    sets: (st.sets||[]).map(s => ({
      id: s.id, name: s.name,
      cards: compactCards(s.cards||[])
    }))
  };
}

/* =================== Sync UI & Debounce =================== */
function setSync(text, cls='work'){
  el.sync.className = cls ? cls.replace(/^/,'') : '';
  el.sync.classList.add(cls);
  el.sync.id = 'syncStatus';
  el.sync.textContent = text;
}
function setDirty(){
  dirty = true;
  setSync('Thay ƒë·ªïi c·ª•c b·ªô ‚Äî ch·ªù ƒë·ªìng b·ªô‚Ä¶', 'work');
  schedulePush();
}
function schedulePush(delay=1500){
  clearTimeout(pushTimer);
  pushTimer = setTimeout(()=> cloudPush(true).catch(()=>{}), delay);
}

/* =================== Cloud: Pull/Push (ƒëa b·ªô, gi·ªØ v·ªã tr√≠) =================== */
async function cloudPull(silent=true){
  try{
    if(!silent) setSync('ƒêang t·∫£i t·ª´ cloud‚Ä¶','work');

    // Ghi nh·ªõ l·ª±a ch·ªçn hi·ªán t·∫°i ƒë·ªÉ kh√¥ng ‚Äúnh·∫£y v·ªÅ ƒë·∫ßu‚Äù
    const prevActiveSetId = state.activeSetId;
    const prevIndex = Math.max(0, indexOfCurrent());
    const prevId = currentId;
    const wasFlipped = flipped;

    const url = `${API_URL}?op=get&token=${encodeURIComponent(API_TOKEN)}`;
    const j = await jsonp(url);
    if(!j || !j.ok){ setSync('Cloud pull th·∫•t b·∫°i', 'err'); throw new Error('pull-failed'); }

    if(!dirty){
      /* ---- ∆ØU TI√äN 1: stateFull (m·ªõi) ---- */
      if (j.stateFull && Array.isArray(j.stateFull.sets)) {
        const remote = j.stateFull;
        state = { version:4, activeSetId: remote.activeSetId || prevActiveSetId, sets: [] };
        state.sets = remote.sets.map(rs => ({
          id: rs.id, name: rs.name || 'B·ªô m·ªõi',
          cards: expandCards(rs.cards || [])
        }));
      }
      /* ---- ∆ØU TI√äN 2: state.sets[*].cards (backend c≈© c·ªßa b·∫°n) ---- */
      else if (j.state && Array.isArray(j.state.sets) && j.state.sets.some(s=>Array.isArray(s.cards))) {
        const remote = j.state;
        state = { version:4, activeSetId: remote.activeSetId || prevActiveSetId, sets: [] };
        state.sets = remote.sets.map(rs => ({
          id: rs.id, name: rs.name || 'B·ªô m·ªõi',
          cards: Array.isArray(rs.cards) ? expandCards(rs.cards) : []
        }));
      }
      /* ---- ∆ØU TI√äN 3: ch·ªâ danh s√°ch b·ªô, th·∫ª n·∫±m ri√™ng ---- */
      else if (j.state) {
        const remoteSets = Array.isArray(j.state.sets) ? j.state.sets : [];
        const localById = Object.fromEntries((state.sets||[]).map(s=>[s.id,s]));
        const mergedSets = remoteSets.map(s=>{
          const old = localById[s.id];
          return old ? { ...old, name: s.name||old.name } : { id:s.id, name:s.name||'B·ªô m·ªõi', cards:[] };
        });
        for(const s of state.sets||[]){
          if(!mergedSets.find(x=>x.id===s.id)) mergedSets.push(s);
        }
        state = {
          version: 4,
          activeSetId: mergedSets.find(x=>x.id===prevActiveSetId) ? prevActiveSetId : (j.state.activeSetId || mergedSets[0]?.id),
          sets: mergedSets
        };

        // cardsBySet / cards / data
        if (j.cardsBySet && typeof j.cardsBySet === 'object'){
          for(const setId in j.cardsBySet){
            const s = state.sets.find(x=>x.id===setId);
            if(s){ s.cards = expandCards(j.cardsBySet[setId]); }
          }
        } else if (Array.isArray(j.cards)) {
          const s = activeSet(); if(s){ s.cards = expandCards(j.cards); }
        } else if (Array.isArray(j.data)) {
          const s = activeSet(); if(s){ s.cards = j.data; }
        }
      }
      /* ---- ∆ØU TI√äN 4: ch·ªâ cards (r·∫•t c≈©) ---- */
      else if (Array.isArray(j.cards) || Array.isArray(j.data)) {
        const s = activeSet();
        if(s){ s.cards = Array.isArray(j.cards) ? expandCards(j.cards) : j.data; }
      }

      // Ph·ª•c h·ªìi th·∫ª ƒëang xem
      const cardsNow = currentCards();
      let keepId = prevId;
      if (!cardsNow.find(c=>c.id===keepId)) {
        const idx = Math.min(prevIndex, Math.max(0, cardsNow.length-1));
        keepId = cardsNow[idx]?.id || cardsNow[0]?.id || null;
      }
      currentId = keepId;
      flipped = wasFlipped;

      localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); // l∆∞u nh∆∞ng KH√îNG setDirty
      renderSets(); renderCard(); renderList();
      lastSync = Date.now();
      setSync('ƒê√£ ƒë·ªìng b·ªô (pull) ' + hhmmss(new Date(lastSync)), 'ok');
    }

    return true;
  }catch(e){ console.error(e); setSync('Cloud pull l·ªói m·∫°ng', 'err'); throw e; }
}

async function cloudPush(silent=false){
  try{
    // G·ª≠i TO√ÄN B·ªò b·ªô th·∫ª theo 2 d·∫°ng ƒë·ªÉ backend c≈©/m·ªõi ƒë·ªÅu hi·ªÉu:
    // - stateFull: sets[*].cards ƒë√£ compact
    // - state (g·ªçn): ch·ªâ metadata (ph√≤ng khi backend ghi ƒë√®)
    // - (t√πy ch·ªçn) cardsBySet ƒë·ªÉ t∆∞∆°ng th√≠ch th√™m
    const compact = compactState(state);
    const stateFull = buildStateFull(state);

    const cardsBySet = {};
    for(const s of state.sets){
      cardsBySet[s.id] = compactCards(s.cards || []);
    }

    const payload = { compact:true, state: compact, stateFull, cardsBySet };
    const dataB64 = b64webSafeFromJSON(payload);

    // Gi·ªõi h·∫°n an to√†n cho JSONP (URL)
    if (dataB64.length > 7500) {
      setSync('D·ªØ li·ªáu l·ªõn cho JSONP (t√°ch b·ªõt b·ªô / r√∫t ng·∫Øn n·ªôi dung).', 'err');
      throw new Error('payload-too-large');
    }

    if(!silent) setSync('ƒêang ƒë·∫©y l√™n cloud‚Ä¶','work');
    const url = `${API_URL}?op=saveAll&token=${encodeURIComponent(API_TOKEN)}&data=${dataB64}`;
    const j = await jsonp(url, 30000);

    if(j && j.ok){
      dirty = false;
      lastSync = Date.now();
      setSync('ƒê√£ ƒë·ªìng b·ªô (push) ' + hhmmss(new Date(lastSync)), 'ok');
      return true;
    } else {
      setSync('Cloud push: server tr·∫£ v·ªÅ kh√¥ng ok', 'err');
      throw new Error('push-failed-server');
    }
  }catch(e){
    console.error('[push] error:', e);
    if (String(e?.message).includes('payload-too-large')) {
      setSync('Push th·∫•t b·∫°i: URL qu√° d√†i (JSONP).', 'err');
    } else {
      setSync('Cloud push l·ªói m·∫°ng (c√≥ th·ªÉ do URL d√†i).', 'err');
    }
    throw e;
  }
}

/* =================== Events =================== */
// Sets
el.setSelect.onchange = ()=> switchSet(el.setSelect.value);
el.setAddBtn.onclick = ()=>{
  const name = prompt('T√™n b·ªô th·∫ª m·ªõi:', 'B·ªô th·∫ª m·ªõi');
  if(!name) return;
  const s = { id: uid('set_'), name: name.trim(), cards: [] };
  state.sets.unshift(s);
  state.activeSetId = s.id;
  currentId = null;
  saveState();
  renderSets(); renderCard(); renderList();
};
el.setRenameBtn.onclick = ()=>{
  const s = activeSet(); if(!s) return;
  const name = prompt('ƒê·ªïi t√™n b·ªô th·∫ª:', s.name);
  if(!name) return;
  s.name = name.trim();
  saveState(); renderSets(); renderList();
};
el.setDeleteBtn.onclick = ()=>{
  if(state.sets.length <= 1){ alert('C·∫ßn √≠t nh·∫•t 1 b·ªô th·∫ª. Kh√¥ng th·ªÉ xo√°.'); return; }
  const s = activeSet(); if(!s) return;
  if(!confirm(`Xo√° b·ªô "${s.name}"?`)) return;
  state.sets = state.sets.filter(x => x.id !== s.id);
  state.activeSetId = state.sets[0].id;
  currentId = currentCards()[0]?.id || null;
  saveState(); renderSets(); renderCard(); renderList();
};

// Cards
el.card.onclick = ()=>{ flipped = !flipped; renderCard(); };
el.flipBtn.onclick = ()=>{ flipped = !flipped; renderCard(); };
el.knownBtn.onclick = ()=> mark(true);
el.unknownBtn.onclick = ()=> mark(false);
el.prevBtn.onclick = prevCard;
el.nextBtn.onclick = nextCard;
el.deleteBtn.onclick = deleteCurrent;
el.search.oninput = renderList;

el.addBtn.onclick = ()=>{
  const f = el.inFront.value.trim();
  const b = el.inBack.value.trim();
  if(!f || !b) return;
  const card = { id:uid('c_'), front:f, back:b, known:0, unknown:0, last:0, ipa:'', audio:'', example:'' };
  currentCards().unshift(card);
  saveState();
  currentId = card.id; flipped = false;
  renderCard(); renderList(); enrichCardById(card.id, f);
  el.inFront.value=''; el.inBack.value=''; el.frontHint.innerHTML='';
};
el.clearBtn.onclick = ()=>{ el.inFront.value=''; el.inBack.value=''; el.frontHint.innerHTML=''; el.inFront.focus(); };
el.inFront.onblur = previewEnrichFront;
el.speakBtn.onclick = (e)=>{
  e.stopPropagation();
  const c = currentCards().find(x=>x.id===currentId); if(!c) return;
  if(c.audio){ new Audio(c.audio).play(); }
  else{
    try{ const u = new SpeechSynthesisUtterance(c.front); u.lang='en-US'; u.rate=1; speechSynthesis.cancel(); speechSynthesis.speak(u); }catch(_){}
  }
};

window.addEventListener('keydown', (e)=>{
  const tag = e.target && e.target.tagName;
  if(tag === 'INPUT' || tag === 'TEXTAREA') return;
  const k = e.key.toLowerCase();
  if(k === ' ' || k === 'enter'){ e.preventDefault(); flipped=!flipped; renderCard(); }
  else if(k === 'a'){ mark(true); }
  else if(k === 'd'){ mark(false); }
  else if(k === 'arrowleft'){ e.preventDefault(); prevCard(); }
  else if(k === 'arrowright'){ e.preventDefault(); nextCard(); }
  else if(k === 'delete'){ e.preventDefault(); deleteCurrent(); }
  else if(k === 'n'){ el.inFront.focus(); }
});

/* G·ª£i √Ω IPA khi r·ªùi √¥ "M·∫∑t tr∆∞·ªõc" */
async function previewEnrichFront(){
  const f = el.inFront.value.trim();
  if(!f){ el.frontHint.innerHTML=''; return; }
  el.loading.hidden = false;
  const d = await fetchDictionary(f);
  el.frontHint.innerHTML = d.ipa ? `<small>IPA g·ª£i √Ω: ${escapeHTML(d.ipa)}</small>` : '';
  el.loading.hidden = true;
}

/* =================== Kh·ªüi ƒë·ªông + Auto Sync =================== */
function renderAll(){ renderSets(); renderCard(); renderList(); }

(async function init(){
  renderAll();
  setSync('ƒêang t·∫£i d·ªØ li·ªáu‚Ä¶','work');
  await cloudPull(true).catch(()=>{});
  setSync('S·∫µn s√†ng', 'ok');

  let dirtySince = 0;
  function autoSyncTick(){
    if (dirty) {
      if (!dirtySince) dirtySince = Date.now();
      cloudPush(true).catch(()=>{});
      if (Date.now() - dirtySince > 30_000) {
        cloudPull(true).catch(()=>{});
        dirtySince = Date.now();
      }
    } else {
      dirtySince = 0;
      cloudPull(true).catch(()=>{});
    }
  }
  setInterval(autoSyncTick, 10_000); // 10 gi√¢y/l·∫ßn
})();
</script>
</body>
</html>
